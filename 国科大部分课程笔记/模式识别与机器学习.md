# 模式识别与机器学习

# 2023 

## 选择题

### 问题 1：关于批正规化（Batch Normalization），下列说法不正确的是（A）。

A. 增加总的训练时间  
B. 使得梯度稳定  
C. 每个批次单独处理

**解答：**

批正规化的主要目的是为了稳定和加速神经网络的训练，它通过在每一层的每一个批次上进行归一化来减少内部协变量偏移（Internal Covariate Shift）。具体分析各个选项：

- **A. 增加总的训练时间**：不正确。批正规化通常会**减少**训练时间，因为它可以允许更大的学习率并减少权重初始化的敏感性。
- **B. 使得梯度稳定**：正确。批正规化有助于梯度稳定，使得梯度的更新更加平滑。
- **C. 每个批次单独处理**：正确。批正规化是在每个批次上独立执行的，即计算每个批次的均值和方差进行归一化。

所以，**不正确**的说法是 **A. 增加总的训练时间**。

### 问题 2：在Logistic 回归中，如果同时加入 L1 和L2 范数，会产生什么效果？（B)

A. 能解决维度灾难问题  
B. 可以做特征选择，并在一定程度上防止过拟合  
C. 在每个样本上获得更准确的结果

**解答：**

在Logistic回归中，加入L1和L2范数的正则化被称为Elastic Net正则化。这种正则化方法结合了L1正则化（Lasso）和L2正则化（Ridge）的优点。

- **L1正则化**（Lasso）：可以产生稀疏解，即某些特征的权重会被压缩到零，从而实现特征选择。
- **L2正则化**（Ridge）：可以防止模型过拟合，因为它会压缩权重，但不会将权重缩减到零。

结合两者的Elastic Net正则化：

- **A. 能解决维度灾难问题**：不完全正确。维度灾难主要指的是在高维数据下模型训练的难度和计算复杂度增加。Elastic Net可以通过特征选择来减少特征数量，但不直接解决维度灾难。
- **B. 可以做特征选择，并在一定程度上防止过拟合**：正确。Elastic Net既可以通过L1部分进行特征选择，又可以通过L2部分防止过拟合。
- **C. 在每个样本上获得更准确的结果**：不完全正确。正则化方法的主要目的是提高模型的泛化能力和防止过拟合，不一定能保证每个样本的结果更准确。

所以，**正确**的效果是 **B. 可以做特征选择，并在一定程度上防止过拟合**。

### 问题 3：对一个分类任务，我们采用梯度下降法训练得到一个3层的全连接前馈神经网络模型。你发现它在训练集、验证集上的正确率分别为70%、60%（训练集和测试集都很低）。以下哪项操作有可能提高模型在测试集上的性能？（C）

**答案是 C. 增加模型的层数**

#### 原因分析：

1. **现状分析：**
   - **训练集正确率：70%**
   - **验证集正确率：60%**

   从这些结果可以看出，模型在训练集和验证集上的表现都不理想。这表明**模型的表达能力可能不足**，无法有效捕捉数据中的复杂模式。

2. **选项分析：**
   
   - **A. 增加训练数据量：**
     - 增加训练数据量通常有助于提升模型的泛化能力，但现阶段模型在训练集上的表现已经不够好，这表明模型的容量（复杂度）可能不足。因此，增加数据量可能效果有限。
   
   - **B. 减少每层中神经元的数目：**
     - 减少神经元的数量会降低模型的容量，进一步减弱模型的表达能力。在模型已经表现不佳的情况下，这可能会进一步降低模型性能。
   
   - **C. 增加模型的层数：**
     - 增加模型的层数可以提升模型的容量，使其能够学习更复杂的数据模式。这有助于提升模型在训练集和验证集上的表现。

综上所述，增加模型的层数（选项C）有可能提高模型在测试集上的性能，因为它可以增强模型的表达能力，使其更好地捕捉数据中的复杂模式，进而提升训练集和验证集上的准确率。

### 问题 4：下列关于感知器的说法中，哪一个是不正确的？（B）

**答案是 B. 感知器算法可以判别问题是否线性可分**

#### 原因分析：

1. **A. 只要模式类别是线性可分的，感知器算法一定可以在有限步数内找到最优解**
   - 这是正确的。感知器算法有一个理论保证，即如果数据是线性可分的，算法一定能在有限的迭代步数内找到一个将数据正确分类的超平面。

2. **B. 感知器算法可以判别问题是否线性可分**
   - 这是不正确的。感知器算法不能判别数据是否线性可分。算法只能在数据线性可分时收敛，找到一个分类超平面；如果数据不可分，算法会进入无限循环状态，无法得出结论。

3. **C. 感知器算法所得解与初始值的选择有关**
   - 这是正确的。感知器算法最终找到的分类超平面可能会受到初始权重选择的影响，特别是在多种解都可以正确分类数据时，初始值可能导致不同的解。

综上所述，选项B是不正确的，因为感知器算法无法判断数据是否线性可分。它只能在数据线性可分时找到一个解决方案，但无法证明数据不可分时的情况。

### 问题 5：要将两个半月形数据聚成两族，可采用（C）聚类算法。

A. K 均值聚类  
B. 混合高斯模型（GMM)  
C. DBSCAN

**解答：**

在聚类问题中，不同的算法适用于不同的数据分布和结构。两个半月形数据（two moons dataset）是一种非凸的、具有非线性分隔的数据结构。

- **A. K 均值聚类**：不适合。K均值聚类假设簇是球形的，并且通过最小化簇内方差来分配簇，因此它不能有效地处理两个半月形数据。
- **B. 混合高斯模型（GMM)**：也不适合。GMM假设数据是由若干个高斯分布生成的，这对于两个半月形数据同样效果不好，因为高斯分布无法很好地拟合这种非线性结构。
- **C. DBSCAN**：适合。DBSCAN（基于密度的空间聚类应用于噪声）是一种基于密度的聚类方法，能够很好地处理具有任意形状的簇，包括两个半月形数据。

所以，适合将两个半月形数据聚成两族的聚类算法是 **C. DBSCAN**。

### 问题 6：下列哪一项不是半监督学习的假设？（C）

A. 聚类假设  
B. 平滑假设  
C. 高密度分割

**解答：**

半监督学习是利用少量标记数据和大量未标记数据进行学习的一种方法，它基于以下几种假设：

- **A. 聚类假设**：正确。这个假设认为数据点可以聚成若干个簇，且同一簇内的数据点有相同的标签。
- **B. 平滑假设**：正确。这个假设认为在一个高密度区域内，相邻的数据点可能具有相同的标签，标签分布是平滑的。
- **C. 高密度分割**：不正确。高密度分割并不是半监督学习的一个常见假设。常见的假设主要是聚类假设和平滑假设。

所以，**不是**半监督学习假设的是 **C. 高密度分割**。

### 问题 7：下列哪一项技术能缓解深度神经网络模型中的梯度消失问题？（C）

A. 反向传播算法  
B. Sigmoid 激活函数  
C. 批正规化

**解答：**

深度神经网络中的梯度消失问题通常出现在网络层数较多的情况下，特别是在使用某些激活函数（如 Sigmoid）时。以下是对各个选项的分析：

- **A. 反向传播算法**：不正确。反向传播算法是训练神经网络的基础方法，但它本身不能缓解梯度消失问题。
- **B. Sigmoid 激活函数**：不正确。实际上，Sigmoid 激活函数是导致梯度消失问题的原因之一，因为它在极值附近的梯度非常小。
- **C. 批正规化**：正确。批正规化（Batch Normalization）可以通过标准化每一层的输入来缓解梯度消失问题，从而使梯度更稳定，训练过程更顺利。

因此，能缓解深度神经网络模型中的梯度消失问题的是 **C. 批正规化**。

### 问题 7：下列哪一项技术不是现代深度神经网络模型能进行训练的原因（A）

**答案是 A. 反向传播算法**

#### 原因分析：

1. **A. 反向传播算法：**
   - 反向传播算法是训练神经网络的基础方法，但它本身不是现代深度神经网络模型能进行训练的原因。

2. **B. RELU激活函数：**
   - RELU（Rectified Linear Unit）激活函数是深度神经网络中常用的激活函数之一，它能够解决梯度消失的问题，加速网络的收敛速度，同时减少训练过程中的计算量。由于其简单且有效的特性，RELU激活函数被广泛应用于深度学习模型中。

3. **C. 批正规化：**
   - 批正规化（Batch Normalization）是一种用于加速深度神经网络训练的技术，它通过在每个小批量数据上进行归一化操作，加速了网络的收敛速度，使得网络对参数初始化不敏感，同时有助于防止梯度消失和梯度爆炸的问题。

题目是要找出相对来说与现代训练技术关联最弱的一项，那么根据传统和历史视角，反向传播算法最早提出，但深度神经网络的实际突破更多归功于后两者的改进（ReLU 和批正规化）

### 问题 8：假设我们使用 AdaBoost 方法进行分类，基学习器为对数几率回归模型。以下哪个超参数增大，会减少模型的方差？(B)

A. 迭代次数T（基数模型的数目）  
B. 训练样本的数目N  
C. 基模型中特征的维度D

**解答：**

在 AdaBoost 中，模型的方差和偏差是两个关键的性能指标。一般情况下：
偏差反映了模型的预测值与真实值之间的差距。方差反应了模型对训练数据对敏感程度。

- **A. 迭代次数T（基数模型的数目）**：增大迭代次数通常会降低偏差，但可能会增加方差。因此，增加迭代次数通常不会减少模型的方差。
- **B. 训练样本的数目N**：增大训练样本的数目通常会减少模型的方差，因为更多的数据提供了更全面的信息，有助于模型更好地泛化。
- **C. 基模型中特征的维度D**：增大特征的维度通常会增加模型的复杂性，可能会导致方差增加。

因此，会减少模型方差的超参数是 **B. 训练样本的数目N**。

### 问题 9：下面关于集成方法的描述中，哪个是正确的？(C)

1. **A. 使用 Bagging 将弱学习器组合，可以减少方差**
   
2. **B. 使用提升法（Boosting）将强学习器组合，可以减少偏差**
   
3. **C. 使用 Bagging 将强学习器组合，可以减少方差**

**boosting是把弱学习器组合 减小偏差。**

**bagging是把强学习器组合 减小方差。**

要理解为什么 boosting 和 bagging 在机器学习中起到不同的作用，我们需要了解它们的工作原理及其对模型性能的影响。

#### Boosting：减少偏差

**工作原理**：

1. **弱学习器**：Boosting 使用多个弱学习器（通常是简单的模型，如浅层决策树），这些学习器单独表现不佳，但经过组合可以显著提升性能。
2. **顺序训练**：每个学习器都在前一个学习器的基础上进行训练，试图纠正前一个学习器的错误。具体做法是增加那些被前一个模型错分样本的权重，从而使后续模型更关注这些难以分类的样本。
3. **加权投票**：最终的预测是通过加权投票或加权平均的方式将所有弱学习器的结果组合起来。

**效果**：
- **减少偏差**：因为每个后续模型都在纠正前一个模型的错误，所以整体模型可以逐步减小偏差。弱学习器本身可能有很高的偏差，但通过 boosting 的过程，组合后的模型变得更加精确和强大。

#### Bagging：减少方差

**工作原理**：
1. **强学习器**：Bagging 通常使用多个强学习器（如深层决策树）。这些模型单独训练时可能已经有不错的性能。
2. **并行训练**：多个模型在不同的训练数据子集（通过 bootstrap 重采样得到的）上并行训练，每个模型的训练数据集都是从原始数据集中有放回抽样得到的子集。
3. **投票或平均**：最终的预测是通过所有模型的投票（分类任务）或平均（回归任务）来决定的。

**效果**：

- **减少方差**：通过在不同的数据子集上训练多个强学习器，可以减少单个模型的随机性和过拟合风险。各个模型的错误往往不会完全一致，因此综合多个模型的预测结果可以平滑出一些随机噪声，减小模型的方差。

#### 总结

- **Boosting 减少偏差**：通过顺序地训练多个弱学习器，每个模型都尝试纠正前一个模型的错误，逐步提升整体模型的精度。
- **Bagging 减少方差**：通过并行地训练多个强学习器，每个模型在不同的训练子集上独立训练，最终通过投票或平均来减少模型的随机性和过拟合风险。

因此，boosting 和 bagging 的核心区别在于它们处理模型误差的方式：boosting 主要关注减少系统偏差，而 bagging 主要关注减少模型方差。

### 问题 10：以下哪种任务能得到完美优化，即优化器能找到损失函数的全局最小值？(A)

A. 对数几率回归，损失是负log似然损失（交叉熵损失）  
B. 具有一个隐藏层的神经网络，损失是负log似然损失  
C. K均值聚类，损失是每个点到质心的欧氏距离的平方之和

**解答：**

在优化问题中，全局最小值是指找到使损失函数达到最低点的参数组合。以下是对各选项的分析：

- **A. 对数几率回归，损失是负log似然损失（交叉熵损失）**：正确。对数几率回归是一个凸优化问题，其损失函数是凸函数，因此可以通过优化方法（如梯度下降）找到全局最小值。
- **B. 具有一个隐藏层的神经网络，损失是负log似然损失**：不正确。神经网络的损失函数通常是非凸的，存在多个局部最小值，优化器难以保证找到全局最小值。
- **C. K均值聚类，损失是每个点到质心的欧氏距离的平方之和**：不正确。K均值聚类是一个非凸优化问题，容易陷入局部最小值，因此无法保证找到全局最小值。

因此，能得到完美优化的是 **A. 对数几率回归，损失是负log似然损失（交叉熵损失）**。

## 计算题

## 二、给定N个特本{(x1,y1),(x2,y2),...,(xn,yn)},其中xi属于R^D, yi属于{0,1}为类别标签。

（1）给出采用 PCA，将样本特征降至M维的基本步骤。
（2）对于新的样本x属于R^D，如何对其进行降维和重构？

![image-20240607191946907](https://panger-1330565050.cos.ap-beijing.myqcloud.com/202501242319678.png)

![image-20240607192210840](https://panger-1330565050.cos.ap-beijing.myqcloud.com/202501242319015.png)

![image-20240607194034633](https://panger-1330565050.cos.ap-beijing.myqcloud.com/202501242319836.png)

## 三、给定包含有N个样本的数据集{(xi,yi)},xi=(xi1,xi2,...,xiD)为第i个样本的特征，yi属于{0,1}为对应的类别标签。当yi=1时，表示xi为垃圾邮件：yi=0时，表示xi为正常邮件。

（1）请采用贝叶斯分类器构建判别函数，并阐述如何估计相关的参数。
（2）如果将异常邮件误分类为正常邮件的代价为1，将正常邮件误分类为垃圾邮件的代分为5，请阐述如何构建分类器。![image-20240607194348443](https://panger-1330565050.cos.ap-beijing.myqcloud.com/202501242319641.png)

![image-20240607194409996](https://panger-1330565050.cos.ap-beijing.myqcloud.com/202501242319337.png)

![image-20240607194500864](https://panger-1330565050.cos.ap-beijing.myqcloud.com/202501242319223.png)

![image-20240608151722345](https://panger-1330565050.cos.ap-beijing.myqcloud.com/202501242319800.png)

![image-20240608151750101](https://panger-1330565050.cos.ap-beijing.myqcloud.com/202501242320370.png)

![image-20240608151628451](https://panger-1330565050.cos.ap-beijing.myqcloud.com/202501242320257.png)





![image-20240607194056229](https://panger-1330565050.cos.ap-beijing.myqcloud.com/202501242320724.png)

## 四、（12 分）假设你在一家二手车经销公司工作，负责以合理的价格收购车辆，你决定开发一个机器学习模型来预测车辆的价格（元)。

（1）该任务是有监督学习任务还是无监督学习任务？是否是回归任务？是否是分类任务？
（2）现收集关于车辆的信息：使用年限（天)、里程（公里）、生产厂家、型号、价格（元）。你选择对此任务采用线性模型，误差采用高斯噪声误差。请对特征做适当的特征工程，说明模型的候选函数族，需要学习哪些参数？
  (3）假设目标是经验风险最小，请给出目标函数，并给出找到最佳参数的必要步骤。
（4）你发现上述线性模型在训练集和测试集上的性能都不大好，请给出一个改进方案。

### （1）任务类型

- **有监督学习任务还是无监督学习任务？**
  - 这是一个有监督学习任务，因为我们有输入数据（车辆的使用年限、里程、生产厂家、型号）和对应的目标输出（车辆的价格）。

- **是否是回归任务？**
  - 是回归任务，因为目标变量（价格）是连续的。

- **是否是分类任务？**
  - 不是分类任务，因为目标变量不是离散的类别标签，而是连续的价格。

### （2）特征工程、模型候选函数族及参数学习

- **特征工程**：
  1. **使用年限（天）**：可以直接使用，或者进行标准化处理。
  2. **里程（公里）**：可以直接使用，或者进行标准化处理。
  3. **生产厂家**：这是一个类别变量，可以进行独热编码（One-Hot Encoding）。
  4. **型号**：这是一个类别变量，可以进行独热编码（One-Hot Encoding）。
  5. **价格（元）**：目标变量。

- **模型的候选函数族**：
  线性回归模型假设价格 \( y \) 是输入特征的线性组合。假设我们经过特征工程后的特征向量为 \( \mathbf{x} \)，包括使用年限、里程、生产厂家和型号的编码特征。

  线性模型可以表示为：
  $$
  y = \beta_0 + \sum_{j=1}^D \beta_j x_j + \epsilon
  $$
  其中，$ \beta_0 $ 是截距项，$\beta_j$是特征 $ x_j $ 的系数，$\epsilon $ 是高斯噪声误差。

- **需要学习的参数**：
  我们需要学习的参数是线性模型中的系数 $ \beta $ 和截距项 $ \beta_0 $。

### （3）目标函数及找到最佳参数的必要步骤

- **目标函数**：
  我们的目标是最小化经验风险，即最小化训练数据上的均方误差（MSE）。目标函数可以表示为：
  $$
  J(\beta) = \frac{1}{N} \sum_{i=1}^N \left( y_i - \beta_0 - \sum_{j=1}^D \beta_j x_{ij} \right)^2
  $$
  其中，$ N $ 是样本数量，\( y_i \) 是第 \( i \) 个样本的实际价格，\( x_{ij} \) 是第 \( i \) 个样本的第 \( j \) 个特征。

- **找到最佳参数的步骤**：
  1. **初始化**：选择初始参数值 $ \beta_0 $ 和 $\ \beta $。
  2. **计算损失**：计算初始损失 $\ J(\beta) $。
  3. **梯度下降**：
     
     - 计算梯度：
       $$
       \frac{\partial J(\beta)}{\partial \beta_0} = -\frac{2}{N} \sum_{i=1}^N \left( y_i - \beta_0 - \sum_{j=1}^D \beta_j x_{ij} \right)
       $$
       
       $$
       \frac{\partial J(\beta)}{\partial \beta_j} = -\frac{2}{N} \sum_{i=1}^N \left( y_i - \beta_0 - \sum_{j=1}^D \beta_j x_{ij} \right) x_{ij}
       $$
       
     - 更新参数：
       $$
       \beta_0 := \beta_0 - \alpha \frac{\partial J(\beta)}{\partial \beta_0}
       $$
       
       $$
       \beta_j := \beta_j - \alpha \frac{\partial J(\beta)}{\partial \beta_j}
       $$
       
       其中，\( $\alpha$ \) 是学习率。
  4. **重复**：重复步骤 2 和 3 直到收敛。

### （4）改进方案

如果线性模型在训练集和测试集上的性能都不佳，可以考虑以下改进方案：

1. **特征工程**：
   - 增加多项式特征：考虑特征之间的非线性关系，例如使用二次或三次多项式特征。
   - 特征交互：增加特征之间的交互项，例如 $ x_1 \cdot x_2 $。

2. **使用更复杂的模型**：
   - 选择非线性模型，例如决策树、随机森林、梯度提升树（GBDT）、支持向量机（SVM）等。
   - 使用神经网络，特别是深度神经网络（DNN）。

3. **正则化**：
   - 使用 L1 正则化（Lasso）或 L2 正则化（Ridge）来减少过拟合。
   - Elastic Net 正则化结合了 L1 和 L2 正则化的优点。

4. **模型集成**：
   - 使用集成方法，例如 Bagging（如随机森林）或 Boosting（如 XGBoost, LightGBM）。

5. **数据处理**：
   - 增加数据量：收集更多的样本数据。 
   - 数据增强：通过数据增强技术生成更多样本。

6. **模型评估**：
   - 使用交叉验证来选择最佳模型参数。
   - 分析模型误差，寻找模型改进方向（例如，残差分析）。

通过这些改进方案，可以提升模型在训练集和测试集上的性能。

![image-20240607194535290](https://panger-1330565050.cos.ap-beijing.myqcloud.com/202501242320585.png)

![image-20240607194601373](https://panger-1330565050.cos.ap-beijing.myqcloud.com/202501242320582.png)



![image-20240607194114628](https://panger-1330565050.cos.ap-beijing.myqcloud.com/202501242320674.png)

## 五、对于二分类问题，对数几率回归中利用下列计算后验概率：

P(y=1|x) = 1/(1+exp(-w^T*x))

给定N个训练数据集{(xi,yi)}，yi属于{0,1},请给出求解模型参数w的方法（要求施加L2正则项约束）

![image-20240608153527612](https://panger-1330565050.cos.ap-beijing.myqcloud.com/202501242320792.png)



![image-20240607194658664](https://panger-1330565050.cos.ap-beijing.myqcloud.com/202501242320171.png)

![image-20240607194726743](https://panger-1330565050.cos.ap-beijing.myqcloud.com/202501242320719.png)



![image-20240607194129711](https://panger-1330565050.cos.ap-beijing.myqcloud.com/202501242320223.png)

## 六、给定如下训练数据集，x1=(2,2),x2=(3,2),x3=(0,0),y1=1,y2=1,y3=-1

通过求解SVM的对偶问题来求解最大间隔的分类超平面

![image-20240607194755392](https://panger-1330565050.cos.ap-beijing.myqcloud.com/202501242320036.png)

![image-20240607194810807](https://panger-1330565050.cos.ap-beijing.myqcloud.com/202501242320527.png)
![image-20240607194928923](https://panger-1330565050.cos.ap-beijing.myqcloud.com/202501242320046.png)

![image-20240607195003304](https://panger-1330565050.cos.ap-beijing.myqcloud.com/202501242320831.png)

<img src="https://panger-1330565050.cos.ap-beijing.myqcloud.com/202501242320595.png" alt="image-20240608172407458" style="zoom:50%;" />

<img src="https://panger-1330565050.cos.ap-beijing.myqcloud.com/202501242320099.png" alt="image-20240608172619180" style="zoom:50%;" />





![image-20240607194144841](https://panger-1330565050.cos.ap-beijing.myqcloud.com/202501242320908.png)

## 七、请写出两种非线性降维方法，并简述基本原理

非线性降维方法在处理高维数据时非常重要，因为这些方法能够捕捉到数据中的复杂非线性关系。以下是两种常见的非线性降维方法及其基本原理：

### 1. 核主成分分析 (Kernel PCA)

#### 基本原理：
核主成分分析 (Kernel PCA) 是传统主成分分析 (PCA) 的一种非线性扩展，通过使用核技巧将原始数据映射到高维特征空间，再在该高维空间中执行PCA。其基本步骤如下：

1. **选择核函数**：选择合适的核函数 $k(x_i, x_j)$，常见的核函数包括线性核、多项式核、径向基核（RBF）等。

2. **计算核矩阵**：计算数据点之间的核矩阵 \(K\)，其中 $K_{ij} = k(x_i, x_j)$。

3. **中心化核矩阵**：对核矩阵进行中心化，去除数据的均值。

4. **特征值分解**：对中心化后的核矩阵进行特征值分解，得到特征值和特征向量。

5. **降维**：选择前 \(M\) 个最大的特征值对应的特征向量，将数据映射到这些特征向量所构成的空间，从而实现降维。

核 PCA 能够捕捉到数据中的非线性结构，使其在处理非线性数据时比线性 PCA 更为有效。

### 2. 自编码器 (Autoencoder)

#### 基本原理：
自编码器是一种基于神经网络的无监督学习方法，用于学习数据的低维表示（编码）。自编码器由两部分组成：编码器和解码器。编码器将输入数据映射到低维的潜在空间，解码器则将低维表示还原回原始数据。通过最小化重构误差，自编码器能够捕捉数据的主要特征。

#### 步骤：
1. **构建网络结构**：
   - **编码器**：输入层到隐藏层的映射，隐藏层的维度比输入层低，学习数据的低维表示。
     $$
     h = f(W_e x + b_e)
     $$
     其中，\(x\) 是输入数据，\(W_e\) 是编码器的权重矩阵，\(b_e\) 是偏置，\(h\) 是低维表示，\(f\) 是激活函数（如ReLU、Sigmoid）。
   
   - **解码器**：隐藏层到输出层的映射，将低维表示还原回原始数据的维度。
     $$
     \hat{x} = g(W_d h + b_d)
     $$
     其中，\(W_d\) 是解码器的权重矩阵，\(b_d\) 是偏置，\(\hat{x}\) 是重构后的数据，\(g\) 是激活函数。
   
2. **训练自编码器**：
   - 定义损失函数：通常使用均方误差 (MSE) 来衡量重构误差。
     $$
     L(x, \hat{x}) = \|x - \hat{x}\|^2
     $$
     
   - 反向传播：通过反向传播算法优化网络的权重和偏置，使重构误差最小化。
   
3. **降维和重构**：
   
   - **降维**：将输入数据通过编码器映射到低维空间。
     $$
     z = f(W_e x + b_e)
     $$
     
   - **重构**：将低维表示通过解码器还原回原始数据。
     $$
     \hat{x} = g(W_d z + b_d)
     $$
     

#### 自编码器的优势：
- 能够处理非线性的数据结构。
- 网络结构和激活函数可以根据具体问题进行调整，具有很高的灵活性。
- 在降维的同时，还能保留数据的主要特征，有助于后续的分类或聚类任务。

## 八、请给出装袋（Bagging）算法和提升（Boosting）算法的至少三个不同点

![image-20240607195018571](https://panger-1330565050.cos.ap-beijing.myqcloud.com/202501242321759.png)

![image-20240607195028731](https://panger-1330565050.cos.ap-beijing.myqcloud.com/202501242321694.png)

装袋（Bagging）和提升（Boosting）是两种常用的集成学习方法，它们通过结合多个基本学习器（base learners）来提高模型的预测性能。尽管它们都有类似的目标，但在具体实现和原理上有显著的不同。以下是它们的三个主要不同点：

### 1. 训练数据的处理方式

**Bagging：**

- **数据抽样**：Bagging 使用自助采样法（bootstrap sampling）从原始训练数据集中有放回地随机抽取多个子集。这些子集之间可能有重复样本，也可能不包含某些样本。
- **并行训练**：每个子集用于训练一个独立的基本学习器，这些学习器可以并行训练。

**Boosting：**
- **顺序训练**：Boosting 按顺序训练基本学习器，每个新的基本学习器都试图纠正前一个基本学习器的错误。
- **样本加权**：Boosting 在每一轮训练中调整样本的权重，增加之前被错误分类样本的权重，使得新的基本学习器更加关注难分类的样本。

### 2. 模型组合方式

**Bagging：**
- **均值/多数投票**：Bagging 的最终预测结果通过对所有基本学习器的预测结果取平均值（回归任务）或多数投票（分类任务）得到。每个基本学习器的权重相同。
- **降低方差**：Bagging 的主要目的是通过减少模型的方差来提高泛化性能，因为每个基本学习器是独立训练的。

**Boosting：**
- **加权平均**：Boosting 将每个基本学习器的预测结果加权后求和得到最终预测结果。一般情况下，后面训练的基本学习器权重大于前面的。
- **降低偏差**：Boosting 旨在通过逐步减少模型的偏差来提高性能，每个新的基本学习器试图纠正前面学习器的错误。

### 3. 基本学习器的强弱

**Bagging：**
- **强学习器**：Bagging 使用强学习器，如决策树（通常是完全生长的决策树）。每个学习器的能力较强，但通过集成它们进一步提升性能。
- **独立训练**：每个学习器的训练是相互独立的，Bagging 不依赖于学习器之间的关系。

**Boosting：**
- **弱学习器**：Boosting 通常使用弱学习器，如简单的决策树（通常是浅层树，如决策桩）。单个学习器的能力较弱，但通过集成多个学习器显著提高性能。
- **依赖性训练**：每个学习器的训练依赖于之前学习器的结果，Boosting 强调学习器之间的顺序和相互关系。

### 总结

这三点总结了 Bagging 和 Boosting 在数据处理、模型组合和基本学习器选择方面的主要区别：

1. **数据处理方式**：Bagging 使用并行的自助采样法，而 Boosting 采用顺序的样本加权方法。
2. **模型组合方式**：Bagging 通过简单的均值或多数投票来组合模型，主要降低方差；Boosting 通过加权平均来组合模型，主要降低偏差。
3. **基本学习器的强弱**：Bagging 使用强学习器，训练过程独立；Boosting 使用弱学习器，训练过程依赖于前面的学习器。



![image-20240607194226163](https://panger-1330565050.cos.ap-beijing.myqcloud.com/202501242321941.png)

## 九、(10 分）在很多任务中，数据的收集及标注是困难的。例如在工业质检中，需要依据产品的图片来判断产品是否异常。但是异常发生的概率很低，往往难以搜集异常产品的图片。如果给定少量有标注图片样本{(xi,yi)},(i=1~Nl),y属于(0,1)为类别标签(yi=1表示xi为异常数据；yi=0 表示xi为正常数据）和大量无标注样本{(xi,yi)}(i=Nl+1~Nl+Nu)

（1)  如果标注样本中既包含正常样本，也包含异常样本，请设计一个深度模型来完成异常图片检测，并给出理由。
（2）如果标注样本中只有正常样本，请设计一个深度模型来完成异常图片检测，并给出理由。

![image-20240607195046750](https://panger-1330565050.cos.ap-beijing.myqcloud.com/202501242321872.png)



### (1) 有标注样本中既包含正常样本，也包含异常样本

在这种情况下，我们可以设计一个半监督学习的深度模型来完成异常图片检测。具体方法如下：

#### 模型设计：

1. **模型结构**：
   - 使用一个卷积神经网络（CNN）作为特征提取器。
   - 在特征提取器之后连接一个全连接层，用于分类。

2. **损失函数**：
   - 对于有标注样本，使用交叉熵损失函数进行监督训练。
   - 对于无标注样本，可以使用一致性正则化或者伪标签的方法。即对无标注样本进行预测，并使用预测的结果作为伪标签进行训练。

3. **训练过程**：
   - 初始阶段只用有标注样本进行训练。
   - 在训练过程中，逐步加入无标注样本的伪标签进行训练。

#### 具体步骤：

1. **特征提取器**：
   使用预训练的卷积神经网络（如ResNet、VGG）进行特征提取，以提高特征表示能力。
   $$
   z_i = \text{CNN}(x_i)
   $$
   
2. **分类器**：
   将提取的特征输入全连接层进行分类。
   $$
   \hat{y}_i = \sigma(W z_i + b)
   $$
   其中，\($\sigma$\) 是sigmoid激活函数，输出为预测的概率。

3. **损失函数**：
   $$
   L = \frac{1}{N_l} \sum_{i=1}^{N_l} \text{CE}(y_i, \hat{y}_i) + \lambda \frac{1}{N_u} \sum_{i=N_l+1}^{N_l+N_u} \text{CE}(y_i^{\text{pseudo}}, \hat{y}_i)
   $$
   其中，CE表示交叉熵损失，\($y_i^{\text{pseudo}}$\) 是无标注样本的伪标签，\($\lambda$\) 是权衡有标注样本和无标注样本的系数。

#### 理由：
- 使用CNN进行特征提取，能够捕捉图片中的局部特征和全局特征。
- 通过半监督学习方法，利用大量无标注样本，有助于提高模型的泛化能力。
- 交叉熵损失函数适用于二分类问题，有助于提高分类准确性。

### (2) 有标注样本中只有正常样本

在这种情况下，我们可以设计一个基于自编码器的深度模型来完成异常图片检测。具体方法如下：

#### 模型设计：

1. **模型结构**：
   - 使用一个卷积自编码器（CAE），包括编码器和解码器。
   - 编码器将输入图片映射到低维潜在空间，解码器将低维表示还原回原始图片。

2. **损失函数**：
   - 使用重构损失（如均方误差）来训练自编码器，使其能够重构正常图片。

3. **训练过程**：
   - 只使用正常样本进行训练，使自编码器学习正常样本的分布。
   - 在检测阶段，通过计算输入图片的重构误差来判断是否为异常样本。重构误差较大的样本被认为是异常样本。

#### 具体步骤：

1. **编码器**：
   使用卷积神经网络将输入图片映射到低维潜在空间。
   $$
   z_i = \text{Encoder}(x_i)
   $$
   
2. **解码器**：
   将低维表示还原回原始图片的维度。
   $$
   \hat{x}_i = \text{Decoder}(z_i)
   $$
   
3. **重构损失**：
   使用均方误差（MSE）来度量原始图片和重构图片之间的差异。
   $$
   L = \frac{1}{N_l} \sum_{i=1}^{N_l} \|x_i - \hat{x}_i\|^2
   $$
   
4. **异常检测**：
   在检测阶段，通过计算输入图片的重构误差来判断是否为异常样本。设定阈值，当重构误差大于阈值时，将样本标记为异常。
   $$
   \text{Anomaly} \quad \text{if} \quad \|x - \hat{x}\|^2 > \text{threshold}
   $$
   

#### 理由：
- 使用自编码器只训练正常样本，使其学习正常样本的分布，从而有效地检测异常样本。
- 重构误差作为检测标准，能够灵活应对不同类型的异常样本。
- 卷积自编码器能够有效地处理图像数据，保留局部和全局信息，提高检测效果。



# 2021

## 一、（20分，每小题2分）选择题。

## 1、对于两类分类问题，（B）能发现类别不可分的情况。

A.梯度法
B.H-K算法
C.感知器算法



## 2 、下列机器学习模型不属于生成式模型的是 。

A、朴素贝叶斯
B. 隐马尔科夫模型 (HMM) 
C. Logistic Regression（逻辑回归）模型

在机器学习中，生成式模型和判别式模型有不同的特点和应用。生成式模型通过建模数据的联合概率分布 \(P(x, y)\) 来进行分类，而判别式模型直接建模条件概率分布 \(P(y|x)\)。

#### 解析：
- **朴素贝叶斯 (Naive Bayes)**：是一种生成式模型，它通过建模每个类别的条件概率分布 \(P(x|y)\) 和先验概率 \(P(y)\)，然后使用贝叶斯定理计算后验概率 \(P(y|x)\)。
- **隐马尔可夫模型 (HMM)**：也是一种生成式模型，用于序列数据建模，建模联合概率 \(P(x, y)\)。
- **逻辑回归 (Logistic Regression)**：是一种判别式模型，它直接建模条件概率 \(P(y|x)\)，不试图建模数据的联合概率分布。

因此，属于判别式模型，而不是生成式模型的是：

**C. Logistic Regression（逻辑回归）模型**

## 3、下列方法中，不属于无监督特征降维的方法是

A. 主成分分析 （PCA)
B. 线性判别分析 (LDA)
C 自编码器

在特征降维的方法中，有监督和无监督的方法都有应用。无监督特征降维方法不使用类别标签，而有监督特征降维方法使用类别标签来指导降维。

#### 解析：
- **主成分分析 (PCA)**：是一种无监督特征降维方法，它通过寻找数据中方差最大的方向来进行降维，不使用类别标签。
- **线性判别分析 (LDA)**：是一种有监督特征降维方法，它利用类别标签，通过最大化类间方差与类内方差的比值来进行降维。
- **自编码器 (Autoencoder)**：是一种无监督特征降维方法，它通过神经网络结构将数据映射到低维表示，再从低维表示重构原始数据，不使用类别标签。

因此，不属于无监督特征降维的方法是：

**B. 线性判别分析 (LDA)**

## 4 如果模型的偏差很高，我们如何降低模型偏差？

A.在特征空间中减少特征 
B.在特征空间中增加特征
C.增加训练数据的数量

要降低模型的偏差，我们需要增加模型的复杂性，使其能够更好地拟合训练数据。以下是如何通过调整特征和数据来降低模型偏差的选项：

- **A. 在特征空间中减少特征**：这通常会减少模型的复杂性，增加偏差。因此，这不太可能有助于降低模型的偏差。
- **B. 在特征空间中增加特征**：这会增加模型的复杂性，使模型有更多的自由度去拟合训练数据，从而降低偏差。
- **C. 增加训练数据的数量**：虽然增加训练数据可以帮助模型更好地泛化，从而降低方差，但对于偏差过高的问题，这通常不是最有效的解决办法。

因此，正确答案是：

**B. 在特征空间中增加特征**

## 5.对一个分类任务，我们采用梯度下降法训练得到一个 20 层的深度卷积神经网络模型，你发现它在训练集上

的正确率为 98%，但在验证集上的正确率为 70%。以下哪项操作有可能提高模型在测试集上的性能？ 
A   增加正则项的权重
B.  减少训练样本的数量
C．加大模型的训练次数

对于一个分类任务，训练的深度卷积神经网络模型在训练集上的正确率为98%，但在验证集上的正确率为70%，这表明模型在验证集上表现不佳，即存在过拟合问题。

#### 解析：
- **A. 增加正则项的权重**：增加正则项的权重会对模型参数施加更强的惩罚，从而减少模型的复杂性，有助于防止过拟合，提高模型在验证集上的性能。
- **B. 减少训练样本的数量**：减少训练样本的数量通常会降低模型的泛化能力，可能会导致模型在验证集上的性能更差。
- **C. 加大模型的训练次数**：加大模型的训练次数通常会使模型在训练集上拟合得更好，但也可能会加剧过拟合问题，不一定会提高模型在验证集上的性能。

因此，有可能提高模型在测试集上性能的操作是：

**A. 增加正则项的权重**

## 6、要将下图所示的两个半月形数据各聚成两族，可采用（）聚类算法。

A. K均值聚类
B.混合高斯模型 (GM)
C DBSCAN

**解答：**

在聚类问题中，不同的算法适用于不同的数据分布和结构。两个半月形数据（two moons dataset）是一种非凸的、具有非线性分隔的数据结构。

- **A. K 均值聚类**：不适合。K均值聚类假设簇是球形的，并且通过最小化簇内方差来分配簇，因此它不能有效地处理两个半月形数据。
- **B. 混合高斯模型（GMM)**：也不适合。GMM假设数据是由若干个高斯分布生成的，这对于两个半月形数据同样效果不好，因为高斯分布无法很好地拟合这种非线性结构。
- **C. DBSCAN**：适合。DBSCAN（基于密度的空间聚类应用于噪声）是一种基于密度的聚类方法，能够很好地处理具有任意形状的簇，包括两个半月形数据。

所以，适合将两个半月形数据聚成两族的聚类算法是 **C. DBSCAN**。

## 7、下列哪一项不是半监督学习的假设？（）

A. 低密度分离假设
B. 流形假设
C 最小描述长度假设

半监督学习是一种使用少量标注数据和大量未标注数据来训练模型的学习方法。它通常依赖于以下几种假设：

1. **低密度分离假设**：假设不同类别的数据点分布在数据空间的不同密度区域，分类边界应该位于数据密度较低的区域。
2. **流形假设**：假设高维数据点实际上分布在一个低维流形上，这意味着数据点在一个低维空间中有更简单的结构。

**最小描述长度假设**不属于半监督学习的假设。最小描述长度原则来自信息理论，用于选择最优模型，旨在通过选择能够最简洁描述数据的模型来防止过拟合。虽然它在某些情况下可以应用于模型选择，但它不是半监督学习中特有的假设。

因此，正确答案是：

**C. 最小描述长度假设**

8．给定如下图所示的概率图模型，请问下列哪一项正确？（）
![image-20240608204529208](https://panger-1330565050.cos.ap-beijing.myqcloud.com/202501242321917.png)

根据概率图模型中的有向边和节点之间的关系，我们可以推断节点之间的条件独立性。给定如下图所示的概率图模型，请问下列哪一项正确：

A. x1 ⊥ x4：这个说法不正确，因为 x1 与 x4 之间存在一条有向边，所以它们不是独立的。

B. x1 ⊥ x5 | {x3, x4}：这个说法正确。根据概率图模型中的 d-分离条件，当给定节点集合 {x3, x4} 的情况下，x1 和 x5 是条件独立的，因为没有任何路径连接这两个节点，也没有未观察到的节点能够连接它们。

C. x1 ⊥ x3 | x2：这个说法不正确。虽然 x1 和 x3 之间没有直接的边连接，但是它们通过 x2 之间存在间接的关系，因此在给定 x2 的情况下，x1 和 x3 不是独立的。

因此，正确答案是：

B. x1 ⊥ x5 | {x3, x4}

## 9．虽然神经网络在上世纪 80年代就己被提出，但直到近些年才能成功训练深度模型，原因之一是现代深度神经网络采用了（）技术。

A.反向传播算法
B. Sigmoid 激活函数
C.跳跃连接 (skip connect)

虽然神经网络在上世纪80年代就已被提出，但直到近些年才能成功训练深度模型。其成功原因之一是现代深度神经网络采用了一些新技术来解决早期的训练难题。其中一个关键技术是跳跃连接（skip connect）。

#### 解析：

- **A. 反向传播算法**：反向传播算法确实是神经网络训练的基础方法，但它在80年代就已经被广泛应用，并不是现代深度神经网络成功的主要新技术。
- **B. Sigmoid 激活函数**：Sigmoid激活函数在早期神经网络中被广泛使用，但它容易导致梯度消失问题，不适合训练深层神经网络。现代神经网络更常用ReLU等其他激活函数。
- **C. 跳跃连接（skip connect）**：跳跃连接（例如ResNet中的残差连接）是一种在现代深度神经网络中非常成功的技术。它允许梯度直接传播到更早的层，缓解了梯度消失问题，使得训练非常深的网络成为可能。

因此，正确答案是：

**C. 跳跃连接 (skip connect)**

## 10.下列哪一项技术使得卷积神经网络具有非线性建模能力？（）

A.随机梯度下降优化算法
B. RELU 激活函数
C 卷积

卷积神经网络（CNN）的非线性建模能力主要来自于激活函数的应用。

#### 解析：
- **A. 随机梯度下降优化算法**：这是用于训练神经网络的优化算法，虽然对于网络的训练过程至关重要，但它并不是赋予网络非线性建模能力的关键。
- **B. ReLU 激活函数**：激活函数如ReLU（Rectified Linear Unit）是赋予卷积神经网络非线性建模能力的关键技术。它在每一层的卷积或全连接之后应用，使得网络能够学习和表示复杂的非线性关系。
- **C. 卷积**：卷积操作本身是线性的，它通过滤波器进行局部连接和参数共享，但没有引入非线性。因此，卷积操作本身不提供非线性建模能力。

因此，使得卷积神经网络具有非线性建模能力的技术是：

**B. ReLU 激活函数**

## 计算题

![image-20240608204828164](https://panger-1330565050.cos.ap-beijing.myqcloud.com/202501242321180.png)

原题

![image-20240608204815790](https://panger-1330565050.cos.ap-beijing.myqcloud.com/202501242321493.png)

原题

![image-20240608204839625](https://panger-1330565050.cos.ap-beijing.myqcloud.com/202501242321468.png)

原题

![image-20240608204853581](https://panger-1330565050.cos.ap-beijing.myqcloud.com/202501242321976.png)

原题

![image-20240608204904189](https://panger-1330565050.cos.ap-beijing.myqcloud.com/202501242321573.png)

原题

![image-20240608204914002](https://panger-1330565050.cos.ap-beijing.myqcloud.com/202501242321655.png)

原题

![image-20240608204926510](https://panger-1330565050.cos.ap-beijing.myqcloud.com/202501242321948.png)

## 八、假设有3个盒子，每个盒子里装有不同数量的红、蓝两种颜色的小球

盒子1：2个红球，2个蓝球，
盒子2：3个红球，1个蓝球;
盒子3：1个红球，3个蓝球：
每次随机选择一个盒子，并从中抽取一个球（有放回)。
（1）请用隐马尔可夫模型 （HMM) 描述上述过程，并给出参数𝜋,A,B的值：（4分）
（2） 在实验过程中我们只记录了抽取到的球的颜色，忘了记录盒子的标号。假如观测到小球的颜色序列为
O =（红，蓝），请用维特比（Viterbi)） 算法计算最可能的盒子序列。（8分）

为了描述这个问题，我们可以利用隐马尔可夫模型（HMM），其中状态表示选择的盒子，观测值表示抽取到的小球的颜色。

### 1. 参数描述

#### 初始状态概率 $\pi$

假设每次随机选择一个盒子，因此每个盒子被选中的初始概率是相同的：

$$
\pi = \left[ \frac{1}{3}, \frac{1}{3}, \frac{1}{3} \right]
$$

#### 状态转移矩阵 $A$

每次选盒子都是独立的，因此状态转移概率也是均匀分布的，即从任意一个盒子转移到其他盒子的概率是相同的：

$$
A = \begin{bmatrix}
\frac{1}{3} & \frac{1}{3} & \frac{1}{3} \\
\frac{1}{3} & \frac{1}{3} & \frac{1}{3} \\
\frac{1}{3} & \frac{1}{3} & \frac{1}{3}
\end{bmatrix}
$$

#### 观测概率矩阵 $B$

观测到红球或蓝球的概率依据不同盒子而不同：

盒子1：2个红球，2个蓝球
盒子2：3个红球，1个蓝球
盒子3：1个红球，3个蓝球

$$
B = \begin{bmatrix}
\frac{1}{2} & \frac{1}{2} \\
\frac{3}{4} & \frac{1}{4} \\
\frac{1}{4} & \frac{3}{4}
\end{bmatrix}
$$

其中，$B_{ij}$表示从状态$i$（即选中盒子$i$）观测到第$j$种颜色（红色或蓝色）的概率。

### 2. 使用维特比算法计算最可能的盒子序列

观测序列 $O = (\text{红}, \text{蓝})$

我们需要找到最可能的盒子序列 $Q = (q_1, q_2)$ 使得观测序列出现的概率最大。

维特比算法的步骤如下：

#### 初始化

定义 $\delta_t(i)$ 为在时刻$t$状态为$i$且观测序列$O_{1:t}$概率的最大值，$\psi_t(i)$ 为路径的最优前驱状态。

$$
\delta_1(i) = \pi_i \cdot B_{i,O_1}
$$

对于观测到的第一个红球（红色对应第1列）：

$$
\delta_1(1) = \frac{1}{3} \cdot \frac{1}{2} = \frac{1}{6}
$$
$$
\delta_1(2) = \frac{1}{3} \cdot \frac{3}{4} = \frac{1}{4}
$$
$$
\delta_1(3) = \frac{1}{3} \cdot \frac{1}{4} = \frac{1}{12}
$$

#### 递推

$$
\delta_{t+1}(j) = \max_i \left( \delta_t(i) \cdot A_{ij} \right) \cdot B_{j,O_{t+1}}
$$
$$
\psi_{t+1}(j) = \arg \max_i \left( \delta_t(i) \cdot A_{ij} \right)
$$

对于第二个观测值蓝球（蓝色对应第2列）：

$$
\delta_2(1) = \max \left( \delta_1(1) \cdot \frac{1}{3}, \delta_1(2) \cdot \frac{1}{3}, \delta_1(3) \cdot \frac{1}{3} \right) \cdot \frac{1}{2}
$$

$$
= \max \left( \frac{1}{6} \cdot \frac{1}{3}, \frac{1}{4} \cdot \frac{1}{3}, \frac{1}{12} \cdot \frac{1}{3} \right) \cdot \frac{1}{2}
$$

$$
= \max \left( \frac{1}{18}, \frac{1}{12}, \frac{1}{36} \right) \cdot \frac{1}{2} = \frac{1}{12} \cdot \frac{1}{2} = \frac{1}{24}
$$

$$
\delta_2(2) = \max \left( \delta_1(1) \cdot \frac{1}{3}, \delta_1(2) \cdot \frac{1}{3}, \delta_1(3) \cdot \frac{1}{3} \right) \cdot \frac{1}{4}
$$

$$
= \max \left( \frac{1}{6} \cdot \frac{1}{3}, \frac{1}{4} \cdot \frac{1}{3}, \frac{1}{12} \cdot \frac{1}{3} \right) \cdot \frac{1}{4}
$$

$$
= \max \left( \frac{1}{18}, \frac{1}{12}, \frac{1}{36} \right) \cdot \frac{1}{4} = \frac{1}{12} \cdot \frac{1}{4} = \frac{1}{48}
$$

$$
\delta_2(3) = \max \left( \delta_1(1) \cdot \frac{1}{3}, \delta_1(2) \cdot \frac{1}{3}, \delta_1(3) \cdot \frac{1}{3} \right) \cdot \frac{3}{4}
$$

$$
= \max \left( \frac{1}{6} \cdot \frac{1}{3}, \frac{1}{4} \cdot \frac{1}{3}, \frac{1}{12} \cdot \frac{1}{3} \right) \cdot \frac{3}{4}
$$

$$
= \max \left( \frac{1}{18}, \frac{1}{12}, \frac{1}{36} \right) \cdot \frac{3}{4} = \frac{1}{12} \cdot \frac{3}{4} = \frac{1}{16}
$$

#### 终止和回溯

找到最终时刻的最优状态：

$$
P^* = \max \left( \delta_T(i) \right)
$$

最优路径的最后一个状态：

$$
q_T^* = \arg \max \left( \delta_T(i) \right)
$$

利用$\psi$进行回溯，得到完整的最优状态序列。

对于这里的情况，$\delta_2(1) = \frac{1}{24}, \delta_2(2) = \frac{1}{48}, \delta_2(3) = \frac{1}{16}$

所以，最优路径的最后一个状态是盒子3。根据$\psi$回溯：

$$
q_2 = 3
$$

由此，我们可以回溯得到最优路径：

$$
q_1 = 2
$$

因此，最可能的盒子序列是 $Q = (2, 3)$。

![image-20240608205409044](https://panger-1330565050.cos.ap-beijing.myqcloud.com/202501242322565.png)

## 九、用于图像分类等任务的卷积神经网络是如何解决从像素级低层语义到物品类别级高层语义之间的“语义鸿沟”问题的？

卷积神经网络（CNNs）通过多层结构和不同类型的层来解决从像素级低层语义到物品类别级高层语义之间的“语义鸿沟”问题。下面是一些关键机制：

### 1. **卷积层（Convolutional Layers）**

- **局部感受野**：卷积层使用局部感受野来捕捉图像局部特征。每个卷积核（filter）只关注图像的一小部分，提取边缘、纹理等低层特征。
- **共享权重**：卷积核在图像上滑动（卷积操作），使得同一个卷积核在不同位置提取特征。这样不仅减少了参数数量，还能捕捉到图像中的重复模式。

### 2. **池化层（Pooling Layers）**

- **降维与不变性**：池化层通过最大池化（Max Pooling）或平均池化（Average Pooling）来降低特征图的维度，同时保留主要特征。这种降维操作可以减少计算量，并增加对图像位置、尺度的鲁棒性。

### 3. **激活函数（Activation Functions）**

- **非线性变换**：激活函数（如ReLU, Sigmoid, Tanh）引入非线性，使得网络可以拟合复杂的函数，提取更高级别的特征。

### 4. **多层结构（Hierarchical Structure）**

- **层级特征表示**：CNN通过多层结构实现从低级特征到高级特征的逐层提取。前几层提取低级特征（如边缘、纹理），中间层组合低级特征形成中级特征（如形状、局部模式），后几层组合中级特征形成高级特征（如物体的部分、整体结构）。
- **深度学习**：网络越深，能捕捉到的特征越复杂。因此，增加网络的深度（层数）是解决语义鸿沟的关键。

### 5. **全连接层（Fully Connected Layers）**

- **特征组合**：全连接层将卷积层和池化层提取到的特征进行组合和分类。通过全连接层，CNN能够将高级特征映射到具体的类别标签。
- **分类决策**：最后的Softmax层将输出映射为类别概率分布，实现最终的分类。

### 6. **批量归一化（Batch Normalization）和正则化（Regularization）**

- **稳定训练**：批量归一化可以加速训练速度并稳定训练过程。
- **防止过拟合**：正则化方法如Dropout、L2正则化可以防止模型过拟合，提高泛化能力。

### 7. **数据增强（Data Augmentation）**

- **提升泛化能力**：通过对训练数据进行各种变换（如旋转、缩放、裁剪、颜色变换等），数据增强技术能够增加训练数据的多样性，提高模型对未见数据的泛化能力。

### 8. **特征重用（Feature Reuse）**

- **跳跃连接**：ResNet等网络通过跳跃连接（skip connections）实现特征重用，避免梯度消失问题，并提升网络的表现力。

这些机制共同作用，使得卷积神经网络能够逐层提取图像的多层次特征，从低层语义到高层语义，从而解决图像分类等任务中的“语义鸿沟”问题。

# 2022

## 1、下列机器学习模型不属于生成式模型的是 。

A.隐马尔科夫模型(HMM) B.高斯判别分析模型 C.感知器算法

在给定的选项中，不属于生成式模型的是感知器算法（Perceptron Algorithm）。

生成式模型是指能够对数据的生成过程进行建模的模型，它们可以估计数据的联合概率分布 \(P(x, y)\)。例如，隐马尔科夫模型 (HMM) 和高斯判别分析模型 (GDA) 都是生成式模型，因为它们可以用于估计数据的联合分布并生成新的数据样本。

感知器算法则是一个判别式模型，它直接学习决策边界，专注于学习输入特征与输出类别之间的关系，即直接估计条件概率 \(P(y|x)\) 或学习决策函数 \(f(x)\)，而不是建模联合分布 \(P(x, y)\)。

因此，正确答案是：

**C. 感知器算法**

## 5、已知右图所示的贝叶斯网络包含 6 个二值变量，该模型的参数共有 ( )个

A.13 B.26 C.64

## 6、依据右面的概率图模型，下列说法正确的是 ()

## 7、下列哪一项不是半监督学习的假设? ()

A.聚类假设 B.平滑假设 C.高密度分割

下列选项中，不是半监督学习的假设的是 **C.高密度分割**。

以下是对每个选项的解释：

A. **聚类假设**：该假设认为在高维空间中，相同类别的数据点倾向于聚集在一起，即同类样本更可能属于同一个簇。这是半监督学习的基础假设之一，尤其是在图形和聚类算法中广泛应用。

B. **平滑假设**：该假设认为数据分布是平滑的，即靠近的样本点有相似的标签。这意味着分类边界应该穿过数据的低密度区域，而不是高密度区域。这是半监督学习的另一重要假设，利用了未标记数据的分布信息。

C. **高密度分割**：这种假设并不是半监督学习的常见假设。实际上，半监督学习更倾向于利用低密度分割假设，认为分类边界应该位于数据分布的低密度区域，而不是高密度区域。

因此，正确答案是：

C. 高密度分割

## 9、下面关于K 均值和 GMM 关系的说法，哪个是正确的? ()

A.K 均值可能会陷入局部最小值，GMM 的EM 算法求解不会
B.GMM 能更好地表示不同方向和大小的族
C.K 均值等价于无限小值的对角协方差的 GMM

关于K均值和GMM（高斯混合模型）的关系，正确的说法是：

**B. GMM能更好地表示不同方向和大小的族**

解释如下：

- **A. K均值可能会陷入局部最小值，GMM的EM算法求解不会**：这句话不正确。实际上，GMM的EM（期望最大化）算法和K均值算法都可能会陷入局部最小值。两者的优化过程都是基于局部搜索方法，因此都可能无法找到全局最优解。

- **B. GMM能更好地表示不同方向和大小的族**：这句话是正确的。K均值假设每个簇是球形且大小相同，而GMM通过使用高斯分布来建模每个簇，可以表示不同形状和大小的簇，包括不同方向和伸展度的族。

- **C. K均值等价于无限小值的对角协方差的GMM**：这句话不完全正确。更准确地说，K均值可以被看作是GMM的一种特殊情况，其中每个高斯分布的协方差矩阵是各向同性的（即球形）并且相同。这意味着在每个维度上都有相同的方差，而不是“无限小值的对角协方差”。

因此，正确答案是：

**B. GMM能更好地表示不同方向和大小的族**

